import { Tweet } from "react-tweet"

Right now, there are a few key players in the [React](https://react.dev) space: [Next.js](http://next.js), [Remix](https://remix.run), and [RedwoodJS](https://redwoodjs.com).

If I stack them next to each other, there are a few key differences. It‚Äôs helpful to recognize these, so you can make informed decisions about the tooling and your developer experience.

Let‚Äôs start with the obvious, **they‚Äôre all running React.** I know some people want to equate Next.js with React, but they are two separate things. Historically, React is considered the frontend layer that provides REACTivity within the browser.

React aside, **the key differences lie in the router and how we fetch and interact with data.** ‚Äì and that‚Äôs really all a framework is, right?! Delivering pages and serving data.

So, let‚Äôs break these down and look at specific code examples.

<div data-node-type="callout">
<div data-node-type="callout-emoji">üí°</div>
<div data-node-type="callout-text">If you're interested in looking at the code in context. <a target="_blank" rel="noopener noreferrer nofollow" href="https://github.com/ahaywood/router-framework-comparison" style={{pointerEvents: 'none'}}>This repo contains examples from all 4 frameworks.</a></div>
</div>

## **The Router**

### **Next.js**

Next.js has two different options, depending on whether you‚Äôre using the **pages API** or the **app API**.

**The pages API** is older, but is more stable and well documented.

It uses a file based routing structure. Meaning, any file placed within the `pages` directory will get turned into a route. For example, `pages/about.js` gives you access to `/about` within the browser. If you want a ‚Äúnested route,‚Äù such as `/about/team`, then you could simply add an `about` folder, with a `team.js` file inside.

<p align="center">
  <img alt="Next.js Pages Router" src="https://cdn.hashnode.com/res/hashnode/image/upload/v1711400586805/39420b95-a5a4-4187-b501-03dc12e691aa.png" />
</p>

<div data-node-type="callout">
<div data-node-type="callout-emoji">‚úè</div>
<div data-node-type="callout-text">In this example, I also moved <code>about.js</code> into the about folder and renamed the file to <code>index.js</code>. Both <code>/pages/about.js</code> and <code>/pages/about/index.js</code> resolve to <code>/about</code></div>
</div>

**The app API** is newer and allows users to incorporate React Server Components (RSC).

All of your files will go inside of the `app` directory, instead of the `pages` directory. With this method, your page file must be called `page.jsx` (or `page.tsx` if you‚Äôre using TypeScript). Since all your page names are the same, it relies on the name of the folder to determine the route name.

Using the same example as above, my `/about` route is the result of `about/page.tsx` and `/about/team` is created by `/about/team/page.tsx`

<p align="center">
  <img alt="Next.js App Router" src="https://cdn.hashnode.com/res/hashnode/image/upload/v1711400765354/0727b753-f38d-46bd-a073-81bfef8c8936.png" />
</p>

What makes this setup particularly interesting is now you can have layout files sprinkled throughout: add a `layout.jsx` (or `layout.tsx`) file.

<p align="center">
  <img alt="Next.js layout file" src="https://cdn.hashnode.com/res/hashnode/image/upload/v1711400802766/54ac0775-b529-42cf-80e4-aa96168e9089.png" />
</p>

Let‚Äôs put some more code behind this. In my `layout.tsx` file:

```javascript
// src/app/about/layout.tsx

export default function AboutLayout({ children }) {
 return (
   <div className="border-2 border-purple-500 m-2 p-2">
     <h1>Layout</h1>
     {children}
   </div>
 );
}
```

Here, I‚Äôm exporting a default function called `AboutLayout`. The only prop I‚Äôm accepting are `children`. If you‚Äôve worked with other frameworks, like Remix (which we‚Äôll get to), this is a similar concept to `Outlets` or `Slots` ([Vue](https://vuejs.org/guide/components/slots.html) and [Svelte](https://svelte.dev/examples/slots)).

I‚Äôm using [Tailwind CSS](https://tailwindcss.com) to create a purple border around my layout. I‚Äôm also giving it some margin and padding to separate it from the edge of the browser.

For my about page (`about/page.tsx`) I have some code:

```javascript
// src/app/about/page.tsx

export default function AboutPage() {
 return (
   <div className="bg-purple-900 p-2 m-2">
     <h1>About Page</h1>
   </div>
 );
}
```

I‚Äôm just displaying an `h1` that says ‚ÄúAbout Page.‚Äù I also added some basic styling to help differentiate the about page from our team page. This has a background color of dark purple and 8px of margin and padding.

If you take a look at this in the browser, you can see that our Layout is wrapping our About Page and the styles from both files are being applied:

<p align="center">
  <img alt="Next.js About Page, with Layout Applied" src="https://cdn.hashnode.com/res/hashnode/image/upload/v1711400966299/f1b0b1d3-b769-4e30-87ec-cc02899d9efd.png" />
</p>

Now, let‚Äôs take a look at our `about/team/page.tsx` file:

```javascript
// src/about/team/page.tsx
export default function TeamPage() {
 return (
   <div className="bg-blue-500 p-2 m-2">
     <h1>Team Page</h1>
   </div>
 );
}
```

Similar to our about page, the team page has an `h1` ‚ÄúTeam Page.‚Äù But, instead of a purple background, I made the background blue.

In the browser at `/about/team`:

<p align="center">
  <img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1711401157274/05d4d331-86da-4ab0-8e3d-b822845c8f8b.png" />
</p>

We can still see the wrapping layout on the team page.

The benefit for using this particular setup is that Next will only render the parts of the route that change. If you navigate between the About and Team pages, the layout box stays.

With this structure, you can also collocate your components with the corresponding page file. For example, you might have a `Headshot.tsx` component that only appears on the team page. It can live in the team folder, right next to your `page.tsx` file.

<p align="center">
  <img alt="Component file within the Next.js App folder" src="https://cdn.hashnode.com/res/hashnode/image/upload/v1711402103147/80cf0db4-1f0c-4148-a2a4-d3a4b4a7d6e1.png" />
</p>

Any shared components, like a Header or Footer component live outside the `app` directory, inside a `components` folder.

<p align="center">
  <img alt="Next.js Shared Components Directory" src="https://cdn.hashnode.com/res/hashnode/image/upload/v1711402394684/ff663a5f-fc99-4c59-955f-a5688f39cf78.png" />
</p>

<div data-node-type="callout">
<div data-node-type="callout-emoji">üí°</div>
<div data-node-type="callout-text">In a Next.js project, you can use the <code>app</code> and <code>pages</code> directory simultaneously. How you want to fetch and serve data determines which routing API you should use. However, if you use both APIs, it‚Äôs easy to create conflicting routes. Fortunately, Next.js will throw a warning within the console if it finds a problem.</div>
</div>

### **Remix**

In Remix v2, the router structure changed drastically. It uses a file/folder based system, but it‚Äôs a flat structure.

Let‚Äôs take a look at how our `/about` and `/about/team` pages would work. We could accomplish the same setup using files:

<p align="center">
  <img alt="Remix Router with Files" src="https://cdn.hashnode.com/res/hashnode/image/upload/v1711402501930/dfaebf24-3832-4528-9ec3-e0987b8016aa.png" />
</p>

Within the `app/routes` directory, I have an `about._index.tsx` file that renders the `/about` page content. And an [`about.team`](http://about.team)`.tsx` file that renders the `/about/team` URL.

Instead of using an `about` folder, it uses a dot notation `.` to generate each URL segment.

Interestingly enough, we can refactor this to use folders, instead of files:

<p align="center">
  <img alt="Remix Router with Folders" src="https://cdn.hashnode.com/res/hashnode/image/upload/v1711402584186/ca7bcefd-bc88-41f1-9a88-e440a555d0f9.png" />
</p>

This looks similar to Next.js‚Äôs app API, except instead of calling each page `page.tsx`, our files are named `route.tsx`.

Some developers like this structure better because they can see, at a glance, all the routes that are available within their application, instead of having to dig through nested folders.

With this setup, you can also collocate route specific components in their corresponding directories. For example, I‚Äôve added the `Headshot.tsx` component to the `about.team` folder.

<p align="center">
  <img alt="Remix Router, Components inside Router" src="https://cdn.hashnode.com/res/hashnode/image/upload/v1711402656650/28ab469d-e975-4959-a499-3d7b45937e55.png" />
</p>

Shared components, used in multiple routes, can live in the `components` directory, outside the `routes` folder.

<p align="center">
  <img alt="Remix Router with a Shared Components Directory" src="https://cdn.hashnode.com/res/hashnode/image/upload/v1711402703802/6fe204af-79b5-4ff5-8ed5-76ccec03e873.png" />
</p>

Similar to Next.js‚Äôs app router, we can also create nested layouts. In order to create a layout that applies to the about and team pages, I‚Äôll add an `about` folder with a `route.tsx` file inside. At first glance, this might seem like it conflicts with the `/about` route. But, the `.index` helps differentiate `about._index/route.tsx` as a page and `about/route.tsx` as a layout.

<p align="center">
  <img alt="Remix Router with a Layout" src="https://cdn.hashnode.com/res/hashnode/image/upload/v1711402766329/92d74050-92ca-40d9-97dc-42f3e5806527.png" />
</p>

Inside our layout file (`about/route.tsx`) I‚Äôll use the same code that we used in our Next.js project, but instead of passing in `children` as a prop, I‚Äôm going to import and display an `Outlet` component.

```javascript
// app/routes/about/route.tsx

import { Outlet } from "@remix-run/react";

export default function AboutLayout() {
 return (
   <div className="border-2 border-purple-500 m-2 p-2">
     <h1>Layout</h1>
     <Outlet />
   </div>
)
```

If we take a look at this within the browser, you‚Äôll notice the same effect:

<p align="center">
  <img alt="About page within Remix" src="https://cdn.hashnode.com/res/hashnode/image/upload/v1711402824242/53989799-4759-4cdb-9b04-c4ad95d87bbd.png" />
</p>

<p align="center">
  <img alt="Team page within Remix" src="https://cdn.hashnode.com/res/hashnode/image/upload/v1711402854749/11277356-9f25-482f-9d6f-99a0b797212f.png" />
</p>

Cool.

### **RedwoodJS**

Now, let‚Äôs take a look at a completely different structure. If you‚Äôre coming from a Rails background, this might look familiar.

Inside the `web/src` directory, there‚Äôs a `Routes.tsx` file. If you take a look at the file now, there‚Äôs not much to see.

```javascript
// web/src/Routes.tsx
import { Router, Route } from '@redwoodjs/router'

const Routes = () => {
 return (
   <Router>
     <Route notfound page={NotFoundPage} />
   </Router>
 )
}

export default Routes
```

So, let‚Äôs generate a couple of pages. One of the cool things about Redwood is that it comes with a command line tool that will generate all the files that we need.

Inside the Terminal, I‚Äôm going to run:

```bash
yarn redwood generate page about
yarn redwood generate page team
```

You can also use the shorthand:

```bash
yarn rw g page about
yarn rw g page team
```

This will generate several files and folders for you. Within the `web/src/pages` directory, I now have an `AboutPage` and a `TeamPage` folder.

<p align="center">
  <img alt="RedwoodJS Web Pages directory" src="https://cdn.hashnode.com/res/hashnode/image/upload/v1711402959795/2f9dc891-7a56-431f-b580-da98b3fe16da.png" />
</p>

Inside each folder, you‚Äôll find three files:

1. a [Storybook](https://storybook.js.org/) file (Redwood supports Storybook out of the box)

2. a test file (Redwood also supports [Jest](https://jestjs.io/), no configuration necessary)

3. a component file


Now, let‚Äôs revisit our `web/src/Routes.tsx` file:

```javascript
// web/src/Routes.tsx
import { Router, Route } from '@redwoodjs/router'

const Routes = () => {
 return (
   <Router>
     <Route path="/team" page={TeamPage} name="team" />
     <Route path="/about" page={AboutPage} name="about" />
     <Route notfound page={NotFoundPage} />
   </Router>
 )
}
```

When we ran the page generators, it also updated our Routes.tsx file for us. Now, we have 2 routes available, /about and /team . If we want to update our team URL to match our other examples, we can simply modify the code:

```javascript
<Route path="/about/team" page={TeamPage} name="team" />
```

Now, let‚Äôs create a layout. Let‚Äôs reach for our command line tool again:

```bash
yarn rw g layout about
```

This will generate 3 more files (a storybook file, test file, and a component file) inside the `web/src/layouts/AboutLayout` directory:

<p align="center">
  <img alt="RedwoodJS About Layout" src="https://cdn.hashnode.com/res/hashnode/image/upload/v1711403063060/6cf2c335-e7b6-45ce-b9a5-ffa88cd9a148.png" />
</p>

Let‚Äôs look at the contents of the `AboutLayout.tsx` file:

```typescript
// web/src/layouts/AboutLayout/AboutLayout.tsx

type AboutLayoutProps = {
 children?: React.ReactNode
}

const AboutLayout = ({ children }: AboutLayoutProps) => {
 return (
   <div className="m-2 border-2 border-purple-500 p-2">
     <h1>Layout</h1>
     {children}
   </div>
 )
}

export default AboutLayout
```

There‚Äôs a little more here, because we‚Äôre using TypeScript, but essentially this file is the exact same as the Next.js layout file.

Now, we need to apply it. Let‚Äôs head back over to our `Routes.tsx` file:

```typescript
// web/src/Routes.tsx

import { Router, Route, Set } from '@redwoodjs/router'

import AboutLayout from './layouts/AboutLayout/AboutLayout'

const Routes = () => {
 return (
   <Router>
     <Set wrap={AboutLayout}>
       <Route path="/about/team" page={TeamPage} name="team" />
       <Route path="/about" page={AboutPage} name="about" />
     </Set>
     <Route notfound page={NotFoundPage} />
   </Router>
 )
}

export default Routes
```

You‚Äôll notice, I wrapped the About and Team Route components  with a Set component and set the wrap attribute to AboutLayout. At the top of the file, I‚Äôm importing our AboutLayout component. (*NOTE:* I  also updated our import statement to include Set.)

Now, let‚Äôs take a look at our pages within the browser:

<p align="center">
  <img alt="Team Page within RedwoodJS" src="https://cdn.hashnode.com/res/hashnode/image/upload/v1711403264754/57f01afb-9a32-4ff7-80de-eef68dd940e9.png" />
</p>

<p align="center">
  <img alt="About page within RedwoodJS" src="https://cdn.hashnode.com/res/hashnode/image/upload/v1711403256793/6dfea65e-0c56-48b5-8f4c-067c7d6e793e.png" />
</p>

Sweet.

## **A Few Thoughts**

If you compare the actual code for the pages and layout files across frameworks, they‚Äôre all very similar, if not exactly the same. Again, that‚Äôs because each of these frameworks are *React* frameworks.

https://gist.github.com/ahaywood/e681e5e9d01295cb21129f4c6041833c

### **File and folder names**

**With Next.js and Remix,** you‚Äôre working with a lot of files that have the same file name (`page.tsx` or `route.tsx`).

This can cause confusion within your Code Editor:

<p align="center">
  <img alt="Tabs within VS Code" src="https://cdn.hashnode.com/res/hashnode/image/upload/v1711403360763/99007e1c-205f-4528-92b9-765ee5599a4b.png" />
</p>

Of course, within VS Code you can always customize the tab names and override the default settings by hitting `Cmd + Shift + P` and typing `settings.json`.

Look to see if the `workbench.editor.labelFormat` property is set.

```json
"workbench.editor.labelFormat": "default",
```

You can experiment with different values such as `medium` and `long`. I keep my editor set at `default`.

This means, if there‚Äôs a file with the same name, then it will simply add the parent directory‚Äôs name to the tab name. Otherwise, it will only show the file name.

Plus, it sounds like some more options are on the way:

<Tweet id="1770810934295970105" />

**Redwood,** on the other hand, uses a different file name for each page and layout. You may have noticed that we generated a page called ‚ÄúAbout‚Äù and a layout called ‚ÄúAbout,‚Äù but Redwood conveniently appended `Page` and `Layout` respectively to differentiate the two types of files.

These may seem like small things, but they become big things, over time, especially if it affects the speed you‚Äôre able to move around your project.

### **Moving files and folders around**

With **Remix and Next.js**, if you need to change a URL, you also need to rename files and folders. This has the potential to cause problems with relative paths and imports. An IDE, like VS Code, generally does a great job of catching these issues and, in many cases, will fix the paths for you. But, it doesn‚Äôt always catch everything.

Not to mention, any links used throughout your site will need to be updated accordingly.

However, **in Redwood**, you can change a URL, without changing the file name. Plus, any route changes do not break the links within your application.

Let me explain with a practical example. Within your application, you have a Login page.

The route looks like this:

```javascript
<Route path="/login" page={LoginPage} name="login" />
```

The project manager requests to change the URL from `/login` to  `/sign-in`

Easy peasy, just update the `path` prop:

```javascript
<Route path="/signin" page={LoginPage} name="login" />
```

I haven‚Äôt introduced the Redwood Link component yet, but this is used to link internal pages throughout your application:

```javascript
<Link to={routes.login()}>Login</Link>
```

The `to` attribute references the `name` of the route, defined in your `Routes.tsx` file. Regardless of how many times the URL (or `path` attribute) changes, the link continues to work. ü§©

### **Working with Pages and Layouts**

With **Next.js and Remix**, the file and folder structure becomes entwined. Maybe, as a developer, you like that? At first glance, it seems nice having all the related pieces together. But, if you leave a project and return six months later, I‚Äôve found it difficult to find exactly what you‚Äôre looking for. It‚Äôs hard to remember what‚Äôs a shared component and what‚Äôs a route specific component. You think you‚Äôll remember, but you don‚Äôt.

Or, within **Remix**, having to process the name of the layout alongside file names can create confusion.

This folder name: `admin.newsletter._details.$id._index` tells me this file is influenced by 3 different layout files üòÖ:

1. An `admin` layout

2. A `newsletter` layout

3. A `_details` layout


For this particular filename, the rendered URL is `/admin/newsletter/1`

That‚Äôs 2 different pieces of information (layouts and URLs) that are communicated within a single folder name. It takes a hot minute to grok.

This might be better communicated through a side-by-side comparison.

In a **Remix** Project:

<p align="center">
  <img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1711403622301/6ef07a6c-9037-449c-a677-239215714a67.png" />
</p>

The same project, ported over to **Redwood**:

<p align="center">
  <img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1711403647856/01e418ca-f5c2-40b8-89f1-2cd7eb323f6d.png" />
</p>

The Redwood structure is much easier to scan.

Let‚Äôs look at another example: VS Code displays folders at the top of a directory listing, followed by files. In this instance, the `showcase` folder at the top of the list contains all the layout details for the showcase page `showcase._index.tsx` listed at the bottom of the screen.

<p align="center">
  <img alt="Folder Structure within Remix Project inside VS Code" src="https://cdn.hashnode.com/res/hashnode/image/upload/v1711403702140/c8dd979f-e255-4d2f-9ebc-fc5ebe8ac989.png" />
</p>

With small projects the flat folder structure in Remix is manageable, but with large projects it becomes unwieldy. Take a look ‚Äì and this isn‚Äôt even a comprehensive list!

<p align="center">
  <img alt="Large Remix Project" src="https://cdn.hashnode.com/res/hashnode/image/upload/v1711403752140/024154cb-396f-4759-92e8-163ee5a47090.png" />
</p>

Not only is it cumbersome prepending admin to every page in the admin section of the site. You‚Äôll also notice file names have a tendency to become long.

## **In Conclusion**

There are so many things to consider when choosing a framework:

* Routing

* Fetching data

* Form submission

* The community

* Support

* Project stability

* Documentation

* Developer Experience


These are all aspects and areas that we develop opinions around when developing Redwood.

Routing is only one aspect. Even though we‚Äôve looked at 4 different variations, there‚Äôs no right or wrong way, just different ways.

I‚Äôd encourage you to build a project on each. I‚Äôve found that I don‚Äôt truly know a framework or understand its perks and pitfalls until I commit an *entire* project or port over an existing one.
